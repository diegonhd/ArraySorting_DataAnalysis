üöÄ Projeto de Benchmark de Algoritmos de Ordena√ß√£oAn√°lise de Desempenho e Complexidade de Algoritmos Cl√°ssicos em Python (1k a 50k Elementos)Este projeto de An√°lise de Algoritmos implementa 10 algoritmos de ordena√ß√£o em Python para realizar um benchmark completo, medindo e comparando a performance em diferentes escalas (at√© 50.000 elementos) e cen√°rios (aleat√≥rio e pior caso). O objetivo √© validar empiricamente as complexidades temporais te√≥ricas ($O(n^2)$, $O(n \log n)$, $O(n+k)$).üéØ Algoritmos AnalisadosO projeto cobre as principais classes de complexidade assint√≥tica, oferecendo uma vis√£o hol√≠stica sobre a efici√™ncia em ordena√ß√£o:Classe de ComplexidadeAlgoritmos ImplementadosComplexidade (Pior Caso)Quadr√°ticaBubble Sort, Selection Sort, Insertion Sort$O(n^2)$Log-LinearQuick Sort, Merge Sort, Heap Sort$O(n^2)$ / $O(n \log n)$Linear (Counting)Counting Sort, Radix Sort, Bucket Sort$O(n+k)$Intermedi√°rioShell Sort (Estrat√©gia n // 2)Pior Caso √© complexo, mas sub-quadr√°tico na pr√°tica.üìà An√°lise e Principais Conclus√µesA an√°lise quantitativa, ilustrada por gr√°ficos de desempenho com escala logar√≠tmica, revela uma clara subdivis√£o de performance e as nuances de cada algoritmo.1. O Ponto de Ruptura: Complexidade Quadr√°tica ($O(n^2)$)Os algoritmos de complexidade quadr√°tica (Bubble Sort, Selection Sort e Insertion Sort) demonstraram o pior desempenho, com tempos de execu√ß√£o na escala de 10¬≤ segundos para $N=50k$. O crescimento de suas curvas √© exponencial no gr√°fico logar√≠tmico, confirmando a inviabilidade para grandes volumes de dados.2. Robustez Log-Linear ($O(n \log n)$)Merge Sort (Estabilidade Garantida): Este algoritmo provou ser o mais est√°vel e previs√≠vel. Seu desempenho √© $O(n \log n)$ em todos os cen√°rios, com as linhas de Caso M√©dio e Pior Caso quase sobrepostas. Essa estabilidade tem o custo de $O(n)$ de espa√ßo extra na mem√≥ria (para c√≥pias de subarrays), validando o trade-off de tempo vs. espa√ßo.Heap Sort (Estabilidade Te√≥rica): Assim como o Merge Sort, o Heap Sort garante uma performance $O(n \log n)$ no pior caso. Suas curvas escalam de forma eficiente, comprovando sua robustez em situa√ß√µes de dados imprevis√≠veis.Shell Sort (Intermedi√°rio Pr√°tico): Embora sua complexidade te√≥rica (com a sequ√™ncia n // 2) tenda a $O(n^2)$, o desempenho pr√°tico foi significativamente superior aos demais $O(n^2)$ e pr√≥ximo aos $O(n \log n)$ para a escala testada, operando em uma escala de tempo 10¬≥ vezes menor que o Bubble Sort.3. A Dicotomia do Quick SortCaso M√©dio (Otimizado): O Quick Sort foi o algoritmo de compara√ß√£o mais r√°pido no caso m√©dio, escalando de forma altamente eficiente.Pior Caso (Vulner√°vel): A utiliza√ß√£o ing√™nua do √∫ltimo elemento como piv√¥ revelou sua fragilidade. No pior cen√°rio testado (arrays inversamente ordenados), o desempenho se degradou para $O(n^2)$, o que √© claramente vis√≠vel no gr√°fico "Compara√ß√£o dos Piores Casos" quando sua linha "salta" para o grupo dos algoritmos lentos.4. Ultra Velocidade: Ordena√ß√£o Linear ($O(n+k)$)Counting Sort e Radix Sort: Estes algoritmos n√£o-comparativos foram, de longe, os mais r√°pidos no benchmark. Suas curvas s√£o praticamente horizontais (crescimento $O(n)$), pois o overhead √© dominado pelo tamanho da lista ($N$) e n√£o pela complexidade logar√≠tmica. Este resultado demonstra a extrema efici√™ncia desses m√©todos para problemas com um range de valores (k) fixo e pequeno.‚öôÔ∏è Estrutura do ProjetoO benchmark foi estruturado em dois notebooks principais para um fluxo de trabalho claro (Execu√ß√£o ‚û°Ô∏è An√°lise):arrays.ipynb (Implementa√ß√£o e Gera√ß√£o de Dados):Cont√©m todas as implementa√ß√µes nativas em Python (com suporte NumPy).Executa os testes de benchmark em 6 tamanhos de array e 4 cen√°rios (3 aleat√≥rios, 1 pior caso).Salva os tempos de execu√ß√£o em arquivos .npy para persist√™ncia.sort_benchmark.ipynb (Processamento e Visualiza√ß√£o):Carrega e processa os dados de tempo usando a biblioteca Pandas.Gera os DataFrames resumidos (resultados_medias.csv e resultados_piores_casos.csv).Utiliza Matplotlib para gerar todos os gr√°ficos comparativos, incluindo o uso estrat√©gico de escala logar√≠tmica para melhor visualizar a diferen√ßa assint√≥tica das classes de complexidade.üõ†Ô∏è Habilidades DemonstradasAn√°lise de Algoritmos: Implementa√ß√£o e valida√ß√£o emp√≠rica das complexidades $O(n^2)$, $O(n \log n)$, e $O(n+k)$.Programa√ß√£o Python Cient√≠fica: Uso eficiente de numpy e pandas para manipula√ß√£o e processamento de dados em larga escala.Visualiza√ß√£o de Dados: Gera√ß√£o de gr√°ficos claros e informativos (matplotlib), incluindo a interpreta√ß√£o de escalas logar√≠tmicas.Engenharia de Software: Benchmarking e testes de estresse de diferentes l√≥gicas de implementa√ß√£o.